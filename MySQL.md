[TOC]

# MySQL

## 基础

### 数据库命令

\c终止命令执行

查看所有数据库:

```sql
show databases;
```

使用某个数据库：

```sql
use databaseName;
```

创建数据库：

```sql
create database databaseName;
```

删除数据库

```sql
drop database databaseName;
```

查看某个数据库下有那些表

```sql
show tables;
```

导入数据

```sql
source SQLpath
```

查询表中全部数据

```sql
select * from tableName;
```

查看表结构

```sql
desc(describe) tableName;
```

  查看MYSQL数据库版本号

```sql
select version();
```

查看当前使用的数据库

```sql
select database();
```

### SQL语句的分类：

DQL：数据查询语言（select）

DML：数据操作语言（对表中数据进行增删改的，insert,delete,update）

DDL：数据定义语言（操作表的结构而不是数据，create，drop，alter）

TCL：事务控制语言（包括事务提交commit，事务回滚rollback）

DCL：数据控制语言（授权grant，撤销权限revoke）



DQL简单查询

查询一个字段

```sql
select 字段名 from 表名;
```

查询多个字段

```sql
select 字段名1,字段名2,... from 表名;
```

查询所有字段

```sql
select * from 表名; //1.效率低；2.可读性差
```

给查询的列取别名（使用as关键字起别名）

```sql
select 字段 as 别名 from 表名;
select 字段 别名 from 表名;
```

别名有空格的时候用引号括起来('别名')

单引号是标准，字符串一般用单引号括起来

字段可以使用数学表达式

```sql
select 字段*10 from 表名;
```

别名是中文，用单引号括起来

条件查询

```sql
select ... from 表名 where 条件 
```

|       符号       |                          意义                          |
| :--------------: | :----------------------------------------------------: |
|     <>或者!=     |                         不等号                         |
|   =;<=;>=;<;>    |                        常用比较                        |
| between...and... |              等同于>= and <= （左小右大）              |
|     is null      |                          为空                          |
|       and        |                          并且                          |
|        or        |                          或者                          |
|       not        |                         非运算                         |
|       like       | 模糊查询支持%和\_（%匹配任意个字符，\_只匹配一个字符） |
|        in        |                      相当于多个or                      |

注:

在数据库中null不能使用等号进行衡量，需要使用`is null`。不为null用`is not null`

`and`优先级比`or`高，不确定优先级的时候多加括号

like需要查找`_`的时候需要转义字符`\`

select可以跟某个表的字段名（也可以等同看做变量名），也可以跟字面量/字面值（数值）。

### 排序

查找默认是升序。

降序

```sql
select * from [表名] order by [字段名] desc,[字段名] desc;
```

升序

```sql
select * from [表名] order by [字段名] asc,[字段名] asc;
```

越前的字段越优先，当前面字段相等的时候才会用到后面字段。

字段名也可以用数字`2`代表第二列，开发中不能写，损失程序的健壮性。

排序总是在sql的最后执行。

### 数据处理函数(单行处理函数)

一个输入对应一个输出。 

| 函数                                          | 功能                                                         |
| --------------------------------------------- | ------------------------------------------------------------ |
| Lower                                         | 转换小写                                                     |
| upper                                         | 转换大写                                                     |
| substr                                        | 取字符串(被截取字符串，起始下标，截取的长度)。起始下标从1开始，没有0. |
| length                                        | 取长度                                                       |
| trim                                          | 去空格（去除前后空白）                                       |
| str_to_date                                   | 将字符串转化成日期                                           |
| date_format                                   | 格式化日期                                                   |
| format                                        | 数字格式化 (format(数字，格式)，格式‘$999,999’)              |
| round                                         | 四舍五入（数值，保留位数：正数表示保留小数位：如1代表保留1位小数，负数代表保留整数位数，如-1为保留到十位） |
| rand()                                        | 生成随机数0-1之间                                            |
| ifnull                                        | 可以将null转换为一个具体值，存在原因:在所有数据库中有NULL参与的数学运算，最终结果都为NULL，ifnull（字段，默认值） |
| concat                                        | 字符串拼接                                                   |
| case...when...then...when...then...else...end | case 字段 when "条件1" then 执行 when "条件2" then 执行2 else 执行3 end |

注：单行处理函数大多是函数名加小括号。

### 分组函数(多行处理函数)

多行处理函数的特点：输入多行，最终输出一行。

| 函数名 | 功能                                                         |
| ------ | ------------------------------------------------------------ |
| count  | 计数:count(具体字段)：统计该字段下所有不为NULL的元素的总数。count(*)：统计总行数，记录数 |
| sum    | 求和                                                         |
| avg    | 平均值                                                       |
| max    | 最大值                                                       |
| min    | 最小值                                                       |

注意：

分组函数在使用的时候必须先进行分组，然后才能使用

如果没有对数据进行分组，整张表为一组

分组函数自动忽略`NULL`,不需要提前处理

### 什么是分组查询？

在实际应用中，可能需要先进行分组，对每一组数据进行操作

```sql
select ... from ... group by ... having ...
```

having可以对分组后的数据进行过滤，但是having不能单独使用，必须和group by联合使用。

优化策略：尽量使用where，where使用不了了再使用having。

### 关键字组合一起

```sql
select ... from ... where ... group by ... order by ... having ...
```

1. from
2. where
3. group by
4. having
5. select
6. order by
7. limit

在一条select语句当中，如果有group by语句的话，select后面只能跟：参与分组的字段，以及分组函数，其他一律不能跟。

分组可以多字段联合分组。

### 去除重复记录

原表数据不会被修改

```sql
select distinct [字段名] from table
```

`distinct`只能出现在所有字段的最前方。

### 连接查询

表连接方式：

​	内连接：

​		等值连接

​		非等值连接

​		自连接

​	外连接：

​		左外连接（左连接）

​		右外连接（右连接）

连接查询会导致笛卡尔积现象。

笛卡尔积现象避免方法：添加条件。

通过笛卡尔积现象得出，表的连接次数越多效率越低，尽量避免表的连接次数过多。

#### 内连接之等值连接

```sql
select ... from [table1] join [table2] on [等值条件] where ...
```

sql99 语法 结构清晰，表的连接条件和where条件分离。

#### 内连接之非等值连接

```sql
select ... from [table1] join [table2] on [连接条件] where ...
```

条件不是一个等量关系，称为非等值连接。

#### 内连接之自连接

```sql
select ... from [table] a join [table] b on a.[字段  ] == b.[字段]  
```

#### 外连接

```sql
select ... from [table1] right/left join [table2] on ...
```

右外连接会把`join`右边表的所有数据都显示

左外连接会把`join`左边表的所有数据都显示

在外连接之中两张表连接产生了主次关系。

任何一个右连接都有左连接的写法，任何一个左连接都有右连接的写法。

#### 多张表连接

```sql
select ... from a join b on a和b的连接条件 join c on a和c的连接条件 join d on a和d的连接条件
```

一条sql中内连接和外连接可以混合使用。

### 子查询

select语句中嵌套select语句，被嵌套的select语句被称为子查询。

```
select ...(select) from ...(select) where ...(select)
```

form后的select可以建立一个临时表。

select后嵌套的select语句查询的结果只能是一个，多于一条会报错。



### union合并查询结果集

union效率较高，相比于`where ... and ...`

union进行结果集合并的时候，要求两个结果集列数相同，数据类型相同。



### limit分页查询

limit是将结果集的一部分取出来，通常是用在分页查询中。

完整用法

```
select ... from ... ... limit startIndex, length
```

缺省用法

```
select ... from ... ... limit length
```

Mysql中limit在order by 之后执行。



### 表的创建(DDL语句)

```
create table 表名(字段名1 数据类型,....,字段名n 数据类型);
```

表名建议以t_或者tbl\_开始，可读性强，见名知意。

常见数据类型：

| 数据类型       | 意义                                                         |
| -------------- | ------------------------------------------------------------ |
| varchar（255） | 可变长度字符串，比较智能，节省空间，根据数据长度动态分配空间，速度慢 |
| char（255）    | 定长字符串，不管实际数据长度，使用不恰当的时候，可能会导致空间的浪费，速度快 |
| int（11）      | 数字中的整数型，等同于java的int                              |
| bigint         | 数字中的长整型，等同于java中的long                           |
| float          | 单精度浮点型数据                                             |
| double         | 双精度浮点型数据                                             |
| date           | 短日期类型                                                   |
| datetime       | 长日期类型                                                   |
| clob           | 字符大对象，最多可以存储4G字符串，存储文章，超过255字符的需要使用clob |
| blob           | 二进制大对象，图片，声音，视频等流媒体数据。                 |

### 表的删除

```sql
drop table tableName;			//表不存在会报错
drop table if existstableName ; //表不存在不会报错
```

### 插入数据

语法格式

```
insert into table(字段1,字段2,...)  values(值1,值2,...)
```

字段名和值要一一对应，数量对应，数据类型对应。

没有给其他字段指定值的话，默认是null。 

前面字段名省略的话，等于都写上。

### insert插入日期

insert插入日期的时候需要用str_to_date函数进行类型转换。

str_to_date('字符串日期','日期格式') 

mysql日期格式

| 格式        | 意义 |
| ----------- | ---- |
| %Y（Y大写） | 年   |
| %m          | 月   |
| %d          | 日   |
| %h          | 时   |
| %i          | 分   |
| %s          | 秒   |

如果提供日期字符串为`%Y-%m-%d`，str_to_date可以忽略。

### select日期以特定形式展示

```
date_format('日期','格式')
```

此函数通常使用在查询日期方面，设置展示的日期格式。

### date和datetime两个类型的区别？

date是短日期，只包括年月日信息。

datetime是长日期，包括年月日时分秒信息。

mysql短日期默认格式`%Y-%m-%d`

mysql长日期默认格式`%Y-%m-%d %h:%i:%s`

### mysql获取当前系统时间

```
now()
```

now获取的时间类型为datetime类型，带有时分秒。

### 修改Update

```
update 表名 set 字段名1 = 值1 ... where 条件;
```

注意：没有条件限制会导致所有数据全部更新。

### 删除delete

```
delete from 表名 where 条件
```

### Insert插入多条记录

```
insert into table(字段1,字段2,...)  values(值1,值2,...),(值1,值2,...),...,(值1,值2,...)
```

### 快速创建表(表的复制)

```
create table tableName as select * from tableName where 条件
```

### 将查询结果插入到一张表中

```
insert into 表名 select * from 表名
```

很少用

### 快速删除表中数据

delete（DML）

```
delete from 表名
```

表中数据被删除了，但是这个数据在硬盘上的真实存储空间不会被释放。

缺点：速度慢

优点：可以回滚

truncate（DDL）

```
truncate table 表名
```

表被一次截断，物理删除

缺点：不支持回滚

优点：速度快

### 对表结构的增删改



添加一个字段



删除一个字段



修改一个字段



### 约束

约束的作用在于保证表中数据有效。

约束在字段后面，称为列级约束，没有在字段后，称为表级约束。

当需要给多个字段联合起来添加某一个约束的时候，需要使用表级约束。

| 约束名     | 关键词                          | 功能                                                         |
| ---------- | ------------------------------- | ------------------------------------------------------------ |
| 非空约束   | not null                        | 非空约束的字段不能为null                                     |
| 唯一性约束 | unique                          | 不能重复，但可以为null，可以联合多个字段进行约束             |
| 主键约束   | primary key(PK)                 | 主键值是每一行的唯一标识，表必须有主键，不能重复，不能为null。多个字段联合起来做主键叫做联合主键。开发中建议使用单一主键。 |
| 外键约束   | foreign key(FK)                 | 父表引用子表的FK，子表该字段至少具有unique约束，不一定是主键 |
| 检查约束   | check(Mysql 不支持，Oracle支持) |                                                              |

当一个字段同时被not null和unique约束的话，该字段自动变成主键字段（Mysql）  

主键值可以分为自然主键和业务主键

自然主键：一个自然数，和业务没关系

业务主键：主键值和业务紧密关联

业务发生变动的时候可能会影响到主键值。

 

### 一，范式的理解

1. 第一范式（原子性） 
2.  第二范式（每一个非主属性都完全依赖于主键）
3. 第三范式（消除传递依赖）
4. BC范式（每个表只应该有一个候选键(不一样的键)）
5.  第四范式（消除多值依赖）

### 二，数据库的ACID特性

- 原子性(Atomic): 事务中的多个操作，不可分割，要么都成功，要么都失败
- 一致性(Consistency): 事务操作之后, 数据库所处的状态和业务规则是一致的
- 隔离性(Isolation): 多个事务之间就像是串行执行一样，不相互影响
- 持久性(Durability): 事务提交后被持久化到永久存储

### 三，MySQL的隔离级别，以及怎么设置Mysql隔离级别

| 类型                         | 脏读 | 不可重复读 | 幻读 |
| ---------------------------- | ---- | ---------- | ---- |
| 未提交读（READ UNCOMMITTED） | 是   | 是         | 是   |
| 已提交读（READ COMMITTED）   |      | 是         | 是   |
| 可重复读（REPEATABLE READ）  |      |            | 是   |
| 串行化（SERIALIZABLE）       |      |            |      |

在客户端设置

```sql
SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL [READ UNCOMMITTED|READ COMMITTED|REPEATABLE READ|SERIALIZABLE]
```

在配置文件中

```sql
[mysqld]
transaction-isolation = REPEATABLE-READ
```

MySQL默认为**REPEATABLE-READ**

#### 四，关系型数据库的特点

- 基于关系代数理论
- 缺点：表结构不直观，实现复杂，速度慢
- 优点：健壮性高，社区庞大

#### 五，乐观锁的使用

通过版本号

```sql
update product set count=20 where productid = 2 and count=21
```

此处模拟商场购物后数目减少1，此处的count=21就相当于版本号的确认

读取数据，记录timestamp或者count，version等

检查版本号 和提交数据

#### 六，事务的性能太慢怎么办？

通过乐观锁,是通过tempstamp或者版本号实现

#### 七，数据库索引是如何实现的？索引的作用

   B树

  B+树

  索引的作用：通过创建索引，可以再查询的过程中，加快查找速度，提高系统的性能

​                        : 约束数据的值，如NUIQUE INDEX,PRIMARY KEY,FOREIGN KEY,，创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

​                      ：在使用分组和排序字句进行数据检索时，可以减少查询中分组和排序的时间。

#### 八，数据库索引的分类

 聚集性索引 ：Clustered_index,每个表至多有一个 ，存放的是记录，一般主键是聚集性的

非聚集性索引：指针，指向那条记录  通过指针找记录，速度慢

按照逻辑角度分类：

   1，主键索引：它是一种特殊的唯一索引，不允许有空值，一般在建表的时候同时创建主索引。

   2，普通索引：最基本的索引，没有任何限制

   3，唯一性索引：它与前面的普通索引类型，不同的就是：索引列值必须唯一，但允许有空值。

  4，复合索引（又叫多列索引，联合索引）

#### 九，数据库B树和B+树的区别

​         B树所有的节点存放值，B+树有用的值存放在叶子节点，根和非叶子节点都是存放的都是指针，通过指针

#### 十,B树和二叉树的区别，红黑树的区别

#### 十一,应该在哪些列上创建索引

   1，经常需要搜索的列上，

   2，作为主键的列上

   3，经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度。

  4，经常需要根据范围搜索的列上

  5，经常需要排序的列上

  6，经常使用在where字句上面的列上

